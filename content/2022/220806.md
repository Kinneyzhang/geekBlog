---
title: "Aug 06, 2022"
type: post
layout: daily
comment: false
---

- 今日待办
  - [X] 写错单dmp开发文档
  - [ ] 总结反思"提醒标语"
  - [ ] 3.1符号表学习，抓核心，做笔记
  - [ ] 思考需要培养什么习惯
    - 早睡早期、博客总结输出、看书、锻炼

- 想法
  - 我要找到那个能每天驱动我不断去积累，不会迷失的点。它就想游戏的复活点，可以让我获得重新出发的力量。
  - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
    - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
      - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
        - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
        
        
- *ImsSortDispatchEnterence*
     - sort 线程
       - 捞取未分发的主工单 (done_tag=0)
       - 判三户冲突(IDTYPE/IDKEY)
         - 有冲突不处理 (0)
         - 无冲突更新状态后放入 *队列* (1)
         - 其余异常 (F)
           
     - dispatch 线程
       - 每次取 *队列* 中的第一条主工单 并 删除
       - 将主工单及其他信息 封装为 /DispatchInfotrade/ 对象 并转为json字符串
       - 根据表名 调用 *ims-cloud-data-service 模块* 对应方法，参数为json字符串
         数据服务模块入口: datatrans > controller > TradeDealController
         - 将json字符串还原成 DispatchInfotrade 对象
         - 根据主工单中的 partitionId 和 eventCode 捞取子工单列表
         - 判断8模式，特殊处理：子工单中至少有一个 operType=8
         - 同时封装 /DatatransContext/ 对象
           
         - 工单处理
           - 错单完工
             - 异动工单搬迁到异动工单历史表
             - 否则搬迁工单到历史表并删除，插入错误工单表(?数据库无此表，本地测试下)。
           - 正常工单
             - *前置准换 processEnter.operProcess(datatransContext);*
               - 调用 *参数模块* 获取参数：ifieldMap, ttableMap, tfieldMap, enumMap
                 注意每个map结构与表中字段的对应关系
                 - Map<Integer, List<TdBIfieldDef>> ifieldMap;
                 - Map<Integer, Map<Integer, TdBTransTable>> ttableMap;
                 - Map<Integer, Map<Integer, Map<Integer, List<TdBTransField>>>> tfieldMap;
                 - Map<Integer, List<TdBTransEnum>> enumMap;
                   
               - 遍历子工单列表，处理 done_tag=0 的子工单
                 - 转换后返回 enumflag
                   - analyzeInfoDtrade(infoDtrade, enumMap, billingList, upField, busiCode, acctMap);
                     - 获取子工单中的 info_type
                     - 根据 info_type 获取 key 为 des_table_code 的 map
                     - 获取该 map 中的所有 key list (des_table_code)
                     - 遍历 des_table_code 列表中 所有 I表 或 帐管表
                       - 根据 TRANS_TYPE 和 TRANS_CONDITION 判断条件转换是否成功(不成功则跳过)
                       - 根据 des_table_code 获取 trans_field map 中的转换数据 map (此时的 key 为 group_id)
                       - 遍历每个分组的转换数据
                         - 封装 *ITableCloud* 对象
                           - 检查 ifield_def 表字段树与 info_str 切割后的个数是否相等
                           - 将 入口表字段 与 对应值 写入 fields
                         - 封装 *TTableCloud* 对象
                           - 根据字段转换表中的字段转换关系(value_method) 计算 fieldValue (具体逻辑看 TTableCloud 类中的 transField方法)
                           - 如果枚举异常 tfileds 置空
                         - 如果 tfileds 为空，donetag置枚举错误，跳过本次循环
                         - 否则
                           - 帐管表
                             - 根据 des_table_name, itable, ttable, infodtrade 等生成I表实体 并 封装成 oTable
                               DataObject oTable = analyzeOFieldAsIms(transTable.getDesTableName().trim(), tTable, infoDtrade, iTable, true);
                             - oTable 数据写入 *acctMap*
                           - 信管表
                             - 根据 des_table_name 和其他数据生成I表实体 并 封装成 oTable
                               DataObject oTable = analyzeOFieldAsIms(transTable.getDesTableName().trim(), tTable, infoDtrade, iTable, false);
                             - 生成上发位供后置使用
                             - oTable 数据写入 *billingList*
                                   
                   - 判断子工单是枚举异常则 donetag 设为5，否则判完工(这里的逻辑有点迷糊?)
                     
               - 根据 data_tag(数据源)，帐管表入帐管库 (acctMap)
                 - 普通表对应：UOP_INFO1 -> UOP_AC1 ... UOP_INFO4 -> UOP_AC4
                 - 特殊表512：无论来源，都入中心库 UOP_CEN.
                   
               - 信管表入I表 (billingList)
                 - 取 billingList 数据入JD域 的 I表
                   
               - 根据 enumflag 设置主工单
                 枚举异常(只是最后一个子工单的枚举状态，是否有必要特地判断?) 或 完工
                 
             - *转换完后* 搬迁工单到历史表并删除，如果是错单同时插入错单表
