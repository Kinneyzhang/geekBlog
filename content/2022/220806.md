---
title: "Aug 06, 2022"
type: post
layout: daily
comment: false
---

- 今日待办
  - [X] 写错单dmp开发文档
  - [ ] 总结反思"提醒标语"
  - [ ] 3.1符号表学习，抓核心，做笔记
  - [ ] 思考需要培养什么习惯
    - 早睡早期、博客总结输出、看书、锻炼

- 想法
  - 我要找到那个能每天驱动我不断去积累，不会迷失的点。它就想游戏的复活点，可以让我获得重新出发的力量。
  - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
    - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
      - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
        - 把 daily page 输出到博客中，精心维护或许是让计划不停的好办法。
        
        
* Python数据模型  
** 一摞Python风格的纸牌
** 如何使用特殊方法
   - 特殊方法是被Python解释器隐式调用的，特点是有双下划线
   - Python内置类型(list, str, bytearray等)，CPython直接使用内存中的C语言结构体，速度更快。
   - 用户一般不直接调用特殊方法，而是使用内置函数来调用特殊方法
     - len(x) -> x.__len__(), str(x) -> x.__str__() ...
   - for i in x 背后调用的是 iter(x) -> x.__iter__()
   - 不要自己随意的添加特殊方法
     
   - 模拟数值类型
     - 实现一个二维向量类，能够实现加法，乘法，取模等运算

       #+BEGIN_SRC python
       from math import hypot

       class Vector:

           def __init__(self, x=0, y=0):
               self.x = x
               self.y = y

           def __repr__(self):
               return 'Vector(%r, %r)' % (self.x, self.y)

           def __abs__(self):
               return hypot(self.x, self.y)

           def __bool__(self):
               return bool(abs(self))

           def __add__(self, other):
               x = self.x + other.x
               y = self.y + other.y
               return Vector(x, y)

           def __mul__(self, scalar):
               return Vector(self.x * scalar, self.y * scalar)

       v1 = Vector(1, 2)
       v2 = Vector(3, 4)
       v3 = v1 + v2
       v4 = v2 * 3
       v3
       v4
       repr(v3)
       bool(v4)
       abs(v2)
       abs(v2 * 3)
       #+END_SRC
       
   - 字符串表示形式
     - Python内置的repr函数能够将一个对象用字符串形式表达出来。
     - repr通过调用__repr__这个特殊方法来实现
   - 算术运算符
     - 通过实现__add__和__mul__这两个特殊方法，给向量带来了+和*这两个运算符。
   - 自定义的布尔值
     - bool(x) 背后调用的是 x.__bool__()
     - 如果不存在__bool__方法，bool(x)会尝试调用x.__len__()，若值为0，返回False，否则为True。

** 特殊方法一览
   - Data Model 中定义了83个特殊方法，其中47个用于算术运算、位运算和比较操作。

* 序列构成的数组
  - Python从ABC语言继承了统一的风格处理序列数据
  - 所有的数据机构：字符串、列表、字节序列、数组、xml元素、数据库查询结构...都有一套完整的操作：迭代、切片=排序、拼接。
** 内置序列类型概览
   - 容器序列：可以存放不同类型的数据，可以是任意类型的对象的引用
     - list, tuple, collections.deque
   - 扁平序列：只能存放一种类型的数据，只能存放诸如字符、字节和数值这些基础类型
     - str, byte, bytearray, memoryview, array.array
   - 可变序列(MutableSequence)
     - list, bytearray, array.array, collections.deque, memoryview
   - 不可变序列(Sequence)
     - tuple, str, bytes
   - Container, Iterable, Sized <- Sequence <- MutableSequence
** 列表推导和生成器表达式
   - 列表推导是构建列表的快捷方式
   - 生成器表达式可以用来创建其他任何类型的序列

*** 列表推导和可读性
    - 使用列表推导，应该尽量保持简短。
    - 如果推导表达式超过两行，应当考虑用for循环重写。
    #+BEGIN_SRC python
    x = 'ABCDE'
    dummy = [ord(x) for x in x]
    x
    dummy
    #+END_SRC

*** 列表推导同filter和map的比较

    #+BEGIN_SRC python
    symbols = 'θζ&¥ʃ'
    beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
    beyond_ascii

    beyond_ascii = list(filter(lambda c: c>127, map(ord, symbols)))
    beyond_ascii
    #+END_SRC

*** 笛卡尔积

    #+BEGIN_SRC python
    colors = ['black', 'white']
    sizes = ['S', 'M', 'L']
    tshirts = [(color, size) for color in colors for size in sizes]
    tshirts
    #+END_SRC

*** 生成器表达式
    - 生成器表达式准守迭代器协议，逐个产出元素，节省内存
    - 使用生成器表达式初始化元组和数组
      #+BEGIN_SRC python
      symbols = 'θζ&¥ʃ'
      tuple(ord(symbol) for symbol in symbols)

      import array
      array.array('I', (ord(symbol) for symbol in symbols))
      #+END_SRC
    - 使用生成器表达式计算笛卡尔积

      #+BEGIN_SRC python
      colors = ['black', 'white']
      sizes = ['S', 'M', 'L']
      for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
          print(tshirt)
      #+END_SRC

** 元组不仅仅是不可变列表

* Django开发
** 开发流程
   * 环境准备与工程创建

     #+BEGIN_SRC sh
     virtualenv <name_env> --python=python3 # 将本地的python库拷贝一份在当前目录下
     source <name_env>/bin/activate, deactivate
     pip3 install Django # 本地已安装则无需执行
     django-admin.py startproject <project_name> .case
     #+END_SRC

   * 连接数据库
     * 修改settings.py中的DATABASES配置(先建一个空数据库)

       #+BEGIN_SRC python
	 DATABASES = {
	     'default': {
		 'ENGINE': 'django.db.backends.mysql',
		 'NAME': 'geekBlog',
		 'USER': 'root',
		 'PASSWORD': '123',
		 'HOST': '127.0.0.1',
		 'POST': '3306',
	     }
	 }
       #+END_SRC
     * pip install pymysql
     * [[https://www.cnblogs.com/TaleG/p/6735099.html][修改相关配置，让python3支持MySQLdb.]]
       * import pymysql
       * pymysql.install_as_MySQLdb()
       * [[https://stackoverflow.com/questions/55657752/django-installing-mysqlclient-error-mysqlclient-1-3-13-or-newer-is-required][the error you may get]]
     * python manage.py migrate
   * 运行服务器
     * python manage.py runserver (port)
   * 创建app
     * python manage.py startapp <app_name>
     * 在工程目录settings.py中将app名称添加到INSTALLED_APPS元组
   * 为app添加模型
     * 模型中的属性决定了表中的字段及相关属性，并在数据库中自动生成
     * [[https://docs.djangoproject.com/en/1.8/ref/models/fields/][django模型字段查询]]
     * python manage.py makemigrations testApp1
     * python manage.py migrate
   * 向管理网站注册模型
     * python manage.py createsuperuser 创建管理网站的超级用户
     * from <app_name>.models import <model_name>
     * admin.site.register(<model_name>)
   * 创建网页
     * 定义url：在项目的urls.py中定义app的url集合，在app的urls.py中定义不同视图的url
     * 编写试图：在app的views.py中定义模版的展示方式
     * 编写模版：html页面
	
** 精通Django
*** 视图与URL配置
    * Django处理请求过程
      * 请求url
      * 查看ROOT_URLCONF找到根url配置
      * 进行url模式匹配
      * 调用对应的视图函数
      * 视图函数返回HttpResponse对象
      * 将HttpResponse对象转换为HTTP响应，得到网页
    * 视图函数：视图函数第一个参数总是HttpRequest对象, 返回值总是HttpResponse对象
    * 动态内容：调用python的datatime模块
    * 动态URL：通过正则匹配实现

*** Django模版
    * 介绍：模版是一些文本字符串，作用是把文本的表现和数据分开。模版定义一些占位符和基本的逻辑(模版标签)，规定如何显示文档。通常模版用于生成HTML，不过Django模版也可以生成任何基于文本的格式。Django模版系统的目的是呈现表现而不是逻辑。

    * 基本用法
      * 编写模版字符串
      * 创建Template对象
      * 创建Context对象
      * 调用render对象

      #+BEGIN_SRC python
      from django import template
      t = template.Template('my name is {{ name }}')
      c = template.Context({'name': 'kinney'})
      print (t.render(c))
      #+END_SRC

    * 上下文变量查找
      * 查找顺序
	* 字典查找
	* 属性查找
	* 方法调用
	* 列表索引查找

    * 模版标签和过滤器
      * if/else
      * for: forloop.counter, forloop.first, forloop.last, forloop.parentloop
      * ifequal/ifnotequal: 参数只能是模版变量，字符串，整数，小数
      * 单行注释: {# this is a comment #}
      * 多行注释:
	{% comment %}
	This is multi-line
	comment.
	{% endcomment %}
      * 过滤器：{{ name|lower }}, 转义{{ value|addslashes }}, {{ my_list|first|upper}}

    * 模版加载机制
      * 模版的配置在settings.py的Templates中
      * backaned定义使用的模版引擎类型
      * dirs中放置模版源文件
      * 项目根目录下放置模版：'DIRS': [os.path.join(BASE_DIR, 'templates')]
      * app_dirs定义是否在安装的应用中查找模版，默认在应用的templates目录中查找
      * options是针对后端的设置

    * render函数：使用get_template()加载模版，但可以更简单，使用django.shortcuts的render函数，返回HttpResponse对象。render(request, 'current_datetime.html', {'current_date': now})

    * 模版继承
      * 创建base.html模版，定义网站的整体外观
      * 为网站中的各个区域创建base_SECTION.html，包含区域专属的样式和设计
      * 为各个页面创建单独的模版

*** Django模型
    * 配置：数据库的配置在settings.py的DATABASES中
    * 命令
      * python manage.py sqlmigrate <app_name> 0001 在屏幕显示对应的SQL语句
      * python manage.py migrate 把迁移的数据库信息写入数据库中
      * python manage.py makemigrations <app_name> 生成模型的数据库的模型迁移文件
    * 基本数据访问

*** Django后台管理
    * python manage.py createsuperuser
    * 在app目录的admin.py中注册模型：admin.site.register(<model_name>)
    * 把字段设置为可选：blank=True; 把日期和数值字段设置为可选：blank=true, null=True
    * 自定义管理后台的内容展示：使用ModelAdmin类
      * 自定义修改列表:
	* 定义继承自ModelAdmin的子类
	* 添加list_display属性，值为字段的元组
	* admin.site.register()的第一个参数为模型名，第二个参数即为定义的ModelAdmin的子类
      * 添加搜索框：设置search_fields属性，值为用于搜索的字段的元组
      * 添加过滤器：设置list_filter属性，值为/超过两个值的字段/的元组，包括DataFiled,BooleanField,ForeignKey等
      * 日期层级导航栏的日期过滤器：data_hierarachy，其值是一个字符串，使用ordering属性进行排序,其值为元组，字段名前加‘-’表示倒序
      * 自定义编辑表单：
	* 使用fields属性，值为元组，按照指定的顺序显示字段，同时排除特定的字段，禁止编辑
	* 定制多对多关系字段：设置filter_horizontal或filter_vertical，当数据量很大时，考虑用raw_id_fields
    * 权限管理
      * Active：是否激活
      * Staff status：是否允许用户登陆管理界面
      * Superuser status：所有权限

*** Django表单
    * 在app目录下新建forms.py建立表单
    * from django import forms, 建立表单类，继承自forms.Form;如果表单的字段与模型字段类似, 继承自forms.ModelForm
    * 表单类中的属性字段定义与模型类类似。required=False设置可选字段
    * 表单对象验证数据，字典传入Form对象
    * 具有有效数据的表单实例有个cleaned_data属性，它的值是一个字典，存储着清理后的提交数据。Django的表单不仅验证数据，还会清理数据，把值转换为适当的python类型
    * 改变字段的渲染方式：使用widget参数，wedget=forms.Textarea
    * 设定最大长度：max_length
    * 设定初始值：使用initial参数，其值是一个字典，传入创建的表单对象，form=ContactForm(initial={'subject':'I love Emacs'})
    * 自定义验证规则：
    * 指定标注：使用label参数
    * 自定义表单外观：

** 部署
    
   #+BEGIN_SRC shell
   rsync -anv --exclude={'.*','migrations','__pycache__','db.sqlite3','media','wikisite/static','settings.py'} ./wikisite root@119.28.186.136:/var/www/
   #+END_SRC
